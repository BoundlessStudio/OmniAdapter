using System.Text.Json.Nodes;
using System.Text.Json.Serialization;

namespace Boundless.OmniAdapter.AzureAi.Models;

public class OutputMessage
{
  public OutputMessage()
  {
  }

  internal OutputMessage(Delta other) => CopyFrom(other);

  /// <summary>
  /// The <see cref="OpenAI.Role"/> of the author of this message.
  /// </summary>
  [JsonInclude]
  [JsonPropertyName("role")]
  public Role Role { get; set; }

  /// <summary>
  /// The contents of the message.
  /// </summary>
  [JsonInclude]
  [JsonPropertyName("content")]
  [JsonIgnore(Condition = JsonIgnoreCondition.Never)]
  public string? Content { get; set; }

  /// <summary>
  /// The tool calls generated by the model, such as function calls.
  /// </summary>
  [JsonInclude]
  [JsonPropertyName("tool_calls")]
  [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
  public List<Tool>? ToolCalls { get; set; }

  internal void CopyFrom(Delta other)
  {
    if (Role == 0 && other?.Role > 0)
    {
      Role = other.Role;
    }

    if (other?.Content != null)
    {
      Content += other.Content;
    }


    //if (other is { ToolCalls: not null })
    //{
    //  toolCalls ??= new List<Tool>();

    //  foreach (var otherToolCall in other.ToolCalls)
    //  {
    //    if (otherToolCall == null) { continue; }

    //    if (otherToolCall.Index.HasValue)
    //    {
    //      if (otherToolCall.Index + 1 > toolCalls.Count)
    //      {
    //        toolCalls.Insert(otherToolCall.Index.Value, new Tool(otherToolCall));
    //      }

    //      toolCalls[otherToolCall.Index.Value].CopyFrom(otherToolCall);
    //    }
    //    else
    //    {
    //      toolCalls.Add(new Tool(otherToolCall));
    //    }
    //  }
  }
}